"""
The following problems are generated by ChatGPT 4o to practice recursion.
Note that some of these problems are similar to what's already covered in this course.
"""

#########################################
###############  BEGINNER ###############
#########################################

"""
Write a recursive function sum_digits(n) that returns the sum of all digits in n.
"""
def sum_digits(n: int) -> int:
    if n >= 0 and n <= 9: return n
    return (n % 10) + sum_digits(n // 10)

try:
    assert sum_digits(123) == 6   # 1 + 2 + 3 = 6
    assert sum_digits(9876) == 30 # 9 + 8 + 7 + 6 = 30
    assert sum_digits(5) == 5     # Base case
    assert sum_digits(0) == 0     # Edge case
    print("All test cases passed! [sum_digits]")
except AssertionError as error:
    print("A test case failed. [sum_digits]")
    print(error.with_traceback())

"""
Write a recursive function count_sevens(n) that returns the number of times 7 appears in the integer n.
"""
def count_sevens(n: int) -> int:
    if n == 7: return 1
    if n >= 0 and n <= 9: return 0
    return (1 if n % 10 == 7 else 0) + count_sevens(n // 10)

try:
    assert count_sevens(777) == 3
    assert count_sevens(1727) == 2
    assert count_sevens(0) == 0
    assert count_sevens(123456) == 0
    print("All test cases passed! [count_sevens]")
except AssertionError as error:
    print("A test case failed. [count_sevens]")
    print(error.with_traceback())

"""
Write a function reverse_string(s) that returns the reverse of s using recursion.
"""
# Since I have no clue how to manipulate strings in Python, I can't use 2 pointers
# to swap characters in-place. Had to do things the "Python way".
# I guess this is how it's done over here: https://stackoverflow.com/questions/5532902/python-reversing-a-string-using-recursion
def reverse_string(s: str) -> str:
    if s == "": return s
    return reverse_string(s[1:]) + s[0]

try:
    assert reverse_string("hello") == "olleh"
    assert reverse_string("recursion") == "noisrucer"
    assert reverse_string("a") == "a"
    assert reverse_string("") == ""
    print("All test cases passed! [reverse_string]")
except AssertionError as error:
    print("A test case failed. [reverse_string]")
    print(error.with_traceback())

#########################################
#############  INTERMEDIATE #############
#########################################

"""
Write a function is_palindrome(s) that returns True if s is a palindrome using recursion.
"""
def is_palindrome(s: str) -> bool:
    if len(s) <= 1: return True
    if s[0] != s[-1]: return False
    return is_palindrome(s[1:-1])

try:
    assert is_palindrome("racecar") == True
    assert is_palindrome("madam") == True
    assert is_palindrome("hello") == False
    assert is_palindrome("a") == True
    assert is_palindrome("") == True
    print("All test cases passed! [is_palindrome]")
except AssertionError as error:
    print("A test case failed. [is_palindrome]")
    print(error.with_traceback())

"""
You are given an m x n grid.
You start at (0,0) and can only move right or down.
Write a function count_paths(m, n) that returns the number of unique paths to the bottom-right corner (m-1, n-1).
"""
# The key part of this problem is that the bottom-right corner is (m-1, n-1).
# This means the recursion needs to happen before reaching m and n.
def count_paths_v1(m: int, n: int) -> int:
    def helper(j: int, k: int) -> int:
        if j == m - 1 and k == n - 1: return 1
        if j > m or k > n: return 0
        return helper(j + 1, k) + helper(j, k + 1)
    return helper(0, 0)

def count_paths_v2(m: int, n: int) -> int:
    if m == 1 and n == 1: return 1
    if m < 1 or n < 1: return 0
    return count_paths_v2(m - 1, n) + count_paths_v2(m, n - 1)

try:
    assert count_paths_v1(2, 2) == 2
    assert count_paths_v1(1, 1) == 1
    assert count_paths_v1(3, 3) == 6
    assert count_paths_v1(3, 2) == 3
    print("All test cases passed! [count_paths_v1]")
except AssertionError as error:
    print("A test case failed. [count_paths_v1]")
    print(error.with_traceback())

try:
    assert count_paths_v2(2, 2) == 2
    assert count_paths_v2(1, 1) == 1
    assert count_paths_v2(3, 3) == 6
    assert count_paths_v2(3, 2) == 3
    print("All test cases passed! [count_paths_v2]")
except AssertionError as error:
    print("A test case failed. [count_paths_v2]")
    print(error.with_traceback())

"""
Implement a recursive function fibonacci(n) to compute the nth Fibonacci number.
"""
def fibonacci(n: int) -> int:
    if n <= 0: return 0
    if n == 1: return 1
    return fibonacci(n - 2) + fibonacci(n - 1)

try:
    assert fibonacci(0) == 0
    assert fibonacci(1) == 1
    assert fibonacci(5) == 5
    assert fibonacci(10) == 55
    print("All test cases passed! [fibonacci]")
except AssertionError as error:
    print("A test case failed. [fibonacci]")
    print(error.with_traceback())

#########################################
###############  ADVANCED ###############
#########################################

"""
Given n pairs of parentheses, write a function generate_parentheses(n) that returns all valid ways to arrange them.
"""
# Intuition: build parentheses recursively
# Notes: I felt like I was close to solving this question; just couldn't figure out
#   how to get test case #2. I was getting `["(())", "()"]` instead of the expectation.
# Solution: After asking ChatGPT 4o for help, it revealed that this a "backtracking" problem.
#   Basically, backtracking is used in decision trees and is recursive in nature.
# Comments: not gonna lie, I really felt like I just needed a little push for this one
#   and I might've gotten a sub-optimal solution with my approach.
OPEN = "("
CLOSE = ")"
def generate_parentheses_attempt(n: int) -> list[str]:
    parentheses = [] 
    
    def r(m: int, p: str) -> str:
        if m <= 0: return ""
        return p + r(m - 1, p)

    def g(m: int) -> None:
        if m <= 0: return
        parentheses.append(r(m, OPEN) + r(m, CLOSE))
        g(m - 1)
    
    g(n)
    print(parentheses)
    return parentheses

# Intuition: ChatGPT 4o
# Implementation: backtracking
def generate_parentheses_solution(n: int) -> list[str]:
    parentheses = []
    
    def backtrack(current: str, open_count: int, close_count: int) -> None:
        # Base Case: If we've placed `n` open and `n` close, the sequence is valid
        if len(current) == 2 * n:
            parentheses.append(current)
            return
        
        # Add an open parenthesis if we still have remaining
        if open_count < n:
            backtrack(current + OPEN, open_count + 1, close_count)
        
        # Add a close parenthesis if it balances an open one
        if close_count < open_count:
            backtrack(current + CLOSE, open_count, close_count + 1)
    
    backtrack("", 0, 0)
    return parentheses

try:
    assert generate_parentheses_solution(1) == ["()"]
    assert generate_parentheses_solution(2) == ["(())", "()()"]
    assert generate_parentheses_solution(3) == ["((()))", "(()())", "(())()", "()(())", "()()()"]
    print("All test cases passed! [generate_parentheses]")
except AssertionError as error:
    print("A test case failed. [generate_parentheses]")
    print(error.with_traceback())